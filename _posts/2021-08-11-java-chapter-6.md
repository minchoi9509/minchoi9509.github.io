---
title:  "자바의 정석"
excerpt: "스터디 내용 추가"

categories: JAVA
tags: [JAVA, TIL]
---

### Q. 클래스 변수 vs 싱글턴 패턴
* 클래스 변수 
	* 인스턴스 변수 앞에 `static`을 붙이면 된다. 
	* 모든 인스턴스가 공통된 저장공간(변수)를 공유하게 된다.
	* 선언 위치는 클래스 영역으로 클래스가 메모리에 올라갈 때 생성된다. 
	* 인스턴스 생성하지 않고 언제라도 바로 사용 할 수 있다.
	* `클래스이름.클래스변수`와 같은 형식으로 사용된다. 클래스가 메모리에 로딩될 때 생성되어 종료될 때까지 유지된다. 
	* 전역변수의 성격을 가진다. 

* 싱글톤 패턴
	* 객체 지향 프로그램에서 인스턴스를 단 하나만 생성하는 디자인 패턴
	* 데이터베이스의 연결과 같은 공용 자원, 자주 변경되지 않는 부분, 설정파일 등.. 
	* 인스턴스가 오직 하나만 생성되는 것을 보장하고 어디에서든 인스턴스에서 접근할 수 있도록 하는 디자인 패턴
	* 하나의 클래스에서 하나의 인스턴스만 생성해서 사용해야 하는 경우 사용 
		* 회사에서 많은 직원들이 1개의 프린터를 공유해서 사용하는 경우 - 하나의 인스턴스에서 print() 메서드를 불러와야 함
	
		
	``` java
		public Class Printer {
			private static Printer printer = new Printer(); // 하나의 클래스 변수
			
			// getPrinter() 메서드를 통해서 인스턴스를 반환 받아서 사용함 
			public static Printer getPrinter() {
				return printer;
			}
		
			public void printer(Resource r) {
			..
			}
		}
	```

### 매개변수 가변 인자
* 가변 인자
	* 가변인자가 선언된 메서드를 호출할 때 마다 배열이 새로 생성됨 = 내부적으로 배열 이용하기 때문
	* String concatenate(String [] str) { .. } vs String concatenate(String .. str)
		* `String[] str`을 배열로 하면 반드시 인자를 지정해줘야 한다는 차이점이 있음
		* 가변인자 `String ..str`을 매개변수로 지정했을 때는 인자가 없이 메소드 사용 가능. 


### 초기화 블록
* 초기화 블록
	* static 초기화 블록
		* static { }
		* 클래스가 로딩될 때 호출, 클래스당 최초 1회 실행
		* 인스턴스 멤버에 접근 할 수 없음
	* 인스턴스 초기화 블록
		* { }
		* 인스턴스가 생성될 때마다 수행 됨
	
	* this() vs this
		* `this()` : 생성자 내 다른 생성자를 호출하는 경우
		* `this` : 클래스 내에서 해당 객체를 가르킴 

## Chapter 7. 객체지향 프로그래밍 2

### 오버라이딩 조건
* 메소드의 이름이 같아야 한다. 
* 매개변수가 같아야 한다.
* 반환 타입이 같아야 한다. 

* 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.  
	* 조상 클래스 메서드가 public 접근 제어자를 가진 경우 그를 오버라이딩 한 메서드는 그보다 좁은 범위의 접근 제어자를 가진 수 없다. 
* 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다. 
* 인스턴스 메서드를 static 메서드로 또는 static 메서드를 인스턴스로 변경하여 오버라이딩 할 수 없다. 

* 조상 클래스에 정의된 static메서드를 자손 클래스에서 똑같은 이름의 static 메서드로 정의할 수 있다. 하지만 그것은 오버라이딩이 아니라 각자 클래스에 정의된 static 메서드이다.

### 제어자의 조합
* 메서드에 static과 abstract를 함께 사용 할 수 없다. 
	* static 메서드는 몸통이 있는 메서드에만 사용할 수 있다. 
* 클래스에 abstract와 final을 동시에 사용할 수 없다. 
	* abstract는 상속을 통해 완성되어야 한다는 의미이고 final은 클래스를 확장할 수 없다는 의미기 때문에 서로 함께 사용 할 수 없다.
* abstract메서드의 접근 제어자가 private일 수 없다. 
	* abstract의 메서드의 접근 제어자가 private인 경우 자손 클래스에서 접근하여 오버라이딩 할 수 없으므로 접근 제어자는 private이 되엇는 안된다.
* 메서드에 private와 final을 같이 사용할 필요는 없다.
	* 접근 제어자가 prviate인 경우 오버라이딩 할 수 없으므로 둘 중 하나만 사용해도 의미가 충분하다. 

### 참조변수의 형변환
* 서로 상속관계에 있는 클래스 사이에서 형변환이 가능하다. 
	* 자손타입 -> 조상타입 (업캐스팅) : 형변환 생략가능
	* 자손타입 <- 조상타입 (다운캐스팅) : 형변환 생략 불가능
* 조상 타입의 인스턴스를 자손 타입의 참조 변수로 참조하는 것은 허용되지 않는다. 
* `instanceof` : 참조변수가 참조하고 있는 실제 인스턴스의 타입을 확인 함
* 멤버 변수가 조상 클래스와 자손 클래스에 중복으로 정의된 경우, 조상 타입의 참조변수를 사용했을 때는 조상 클래스에 선언된 멤버변수가 사용되고, 자손타입의 참조변수를 사용했을 때는 자손 클래스에 선언된 멤버변수가 사용된다. 

### 인터페이스
* 인터페이스에서 정의된 메소드는 `public abstract` 접근 제어자가 생략되어 있는 상태이다.
* 리턴 타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.

### 추상클래스 vs 인터페이스


..


### LinkedList vs ArrayList
* 효과적으로 List 이용하기
* ArrayList
	* 배열 형식임으로 `get` / `set`에 대한 access 속도가 빠름
	* `add` 연산에 대해서 중간에 값을 끼워 넣는 건 불가능하고 새로운 값을 추가하려고 할 때 size를 미리 설정하지 않은 경우에는 크기의 2배가 되는 배열을 생성해서 배열 전체를 복사하여 새로운 배열을 복사하고 제일 뒤에 값을 추가하게 된다. 
	* `remove`의 경우에도 중간 값을 제거하는 경우에 한 칸씩 값을 끌고 와야 함으로 O(n)의 시간 복잡도를 가지게 된다.

* LinkedList 
	* index에 대한 값을 가져오거나 값을 search하는 것에 대해서는 O(n)의 시간 복잡도를 가진다.
	* 원하는 위치에 add를 하는 경우에는 O(n)의 시간 복잡도를 가지지만 요소의 시작과 끝을 `add`하거나 `remove`하는 경우에는 빠르다. 

* `get`과 `set`을 자주 이용한다면 ArrayList
* 처음과 끝에 잦은 삽입과 삭제가 발생한다면 LinkedList

### 왜 List<String> list = new ArrayList<String>(); 와 같은 형태로 사용하나요?
* 차후에 list의 형태를 ArrayList에서 LinkedList로 자료 구조를 변경해야 하는 경우가 왔을 때
	1. ArrayList를 참조 변수로 잡은 경우
		* ArrayList를 참조 변수로 지정한 경우에는 `list` 변수가 ArrayList에 해당하는 특정 메서드를 이용했을 수 있기 때문에 LinkedList로 변경하는 경우 해당 부분을 찾아서 변경 해줘야 함
	2. List를 참조 변수로 잡은 경우
		* 공통 부모인 List에서 제공하는 메소드만 사용했을 것이기 때문에 = new LinkedList<String>으로만 변경해주면 됨
		* `

### Properties
* 애플리케이션의 환경설정과 관련된 속성을 저장하는데 사용되는 클래스

### 제너릭 
* 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능
* 형변환이 필요 없이 `<T>`와 같은 변수를 통해서 타입을 지정 해 줄 수 있음
* 클래스의 객체 생성과 사용
* 사용 해 본 적 없는데 정말 편해 보임.. 
  
