---
title:  "자바의 정석"
excerpt: "스터디 내용 추가"

categories: JAVA
tags: [JAVA, TIL]
---

## Chapter 6. 객체지향 프로그래밍 1

### Q. 클래스 변수 vs 싱글턴 패턴
* 클래스 변수 
	* 인스턴스 변수 앞에 `static`을 붙이면 된다. 
	* 모든 인스턴스가 공통된 저장공간(변수)를 공유하게 된다.
	* 선언 위치는 클래스 영역으로 클래스가 메모리에 올라갈 때 생성된다. 
	* 인스턴스 생성하지 않고 언제라도 바로 사용 할 수 있다.
	* `클래스이름.클래스변수`와 같은 형식으로 사용된다. 클래스가 메모리에 로딩될 때 생성되어 종료될 때까지 유지된다. 
	* 전역변수의 성격을 가진다. 

* 싱글톤 패턴
	* 객체 지향 프로그램에서 인스턴스를 단 하나만 생성하는 디자인 패턴
	* 데이터베이스의 연결과 같은 공용 자원, 자주 변경되지 않는 부분, 설정파일 등.. 
	* 인스턴스가 오직 하나만 생성되는 것을 보장하고 어디에서든 인스턴스에서 접근할 수 있도록 하는 디자인 패턴
	* 하나의 클래스에서 하나의 인스턴스만 생성해서 사용해야 하는 경우 사용 
		* 회사에서 많은 직원들이 1개의 프린터를 공유해서 사용하는 경우 - 하나의 인스턴스에서 print() 메서드를 불러와야 함
	
		
	``` java
		public Class Printer {
			private static Printer printer = new Printer(); // 하나의 클래스 변수
			
			// getPrinter() 메서드를 통해서 인스턴스를 반환 받아서 사용함 
			public static Printer getPrinter() {
				return printer;
			}
		
			public void printer(Resource r) {
			..
			}
		}
	```

### 매개변수 가변 인자
* 가변 인자
	* 가변인자가 선언된 메서드를 호출할 때 마다 배열이 새로 생성됨 = 내부적으로 배열 이용하기 때문
	* String concatenate(String [] str) { .. } vs String concatenate(String .. str)
		* `String[] str`을 배열로 하면 반드시 인자를 지정해줘야 한다는 차이점이 있음
		* 가변인자 `String ..str`을 매개변수로 지정했을 때는 인자가 없이 메소드 사용 가능. 


### 초기화 블록
* 초기화 블록
	* static 초기화 블록
		* static { }
		* 클래스가 로딩될 때 호출, 클래스당 최초 1회 실행
		* 인스턴스 멤버에 접근 할 수 없음
	* 인스턴스 초기화 블록
		* { }
		* 인스턴스가 생성될 때마다 수행 됨
	
	* this() vs this
		* `this()` : 생성자 내 다른 생성자를 호출하는 경우
		* `this` : 클래스 내에서 해당 객체를 가르킴 

## Chapter 7. 객체지향 프로그래밍 2

### 오버라이딩 조건
* 메소드의 이름이 같아야 한다. 
* 매개변수가 같아야 한다.
* 반환 타입이 같아야 한다. 

* 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.  
	* 조상 클래스 메서드가 public 접근 제어자를 가진 경우 그를 오버라이딩 한 메서드는 그보다 좁은 범위의 접근 제어자를 가진 수 없다. 
* 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다. 
* 인스턴스 메서드를 static 메서드로 또는 static 메서드를 인스턴스로 변경하여 오버라이딩 할 수 없다. 

* 조상 클래스에 정의된 static메서드를 자손 클래스에서 똑같은 이름의 static 메서드로 정의할 수 있다. 하지만 그것은 오버라이딩이 아니라 각자 클래스에 정의된 static 메서드이다.

### 제어자의 조합
* 메서드에 static과 abstract를 함께 사용 할 수 없다. 
	* static 메서드는 몸통이 있는 메서드에만 사용할 수 있다. 
* 클래스에 abstract와 final을 동시에 사용할 수 없다. 
	* abstract는 상속을 통해 완성되어야 한다는 의미이고 final은 클래스를 확장할 수 없다는 의미기 때문에 서로 함께 사용 할 수 없다.
* abstract메서드의 접근 제어자가 private일 수 없다. 
	* abstract의 메서드의 접근 제어자가 private인 경우 자손 클래스에서 접근하여 오버라이딩 할 수 없으므로 접근 제어자는 private이 되엇는 안된다.
* 메서드에 private와 final을 같이 사용할 필요는 없다.
	* 접근 제어자가 prviate인 경우 오버라이딩 할 수 없으므로 둘 중 하나만 사용해도 의미가 충분하다. 

### 참조변수의 형변환
* 서로 상속관계에 있는 클래스 사이에서 형변환이 가능하다. 
	* 자손타입 -> 조상타입 (업캐스팅) : 형변환 생략가능
	* 자손타입 <- 조상타입 (다운캐스팅) : 형변환 생략 불가능
* 조상 타입의 인스턴스를 자손 타입의 참조 변수로 참조하는 것은 허용되지 않는다. 
* `instanceof` : 참조변수가 참조하고 있는 실제 인스턴스의 타입을 확인 함
* 멤버 변수가 조상 클래스와 자손 클래스에 중복으로 정의된 경우, 조상 타입의 참조변수를 사용했을 때는 조상 클래스에 선언된 멤버변수가 사용되고, 자손타입의 참조변수를 사용했을 때는 자손 클래스에 선언된 멤버변수가 사용된다. 

### 인터페이스
* 인터페이스에서 정의된 메소드는 `public abstract` 접근 제어자가 생략되어 있는 상태이다.
* 리턴 타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.

### 추상클래스 vs 인터페이스

